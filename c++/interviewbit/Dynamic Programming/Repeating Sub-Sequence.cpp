#include <bits/stdc++.h>
using namespace std;

class Solution
{
public:
    int Solution::anytwo(string A);
};

// Given a string A, find if there is any subsequence that repeats itself.

// A subsequence of a string is defined as a sequence of characters generated by deleting some characters in the string without changing the order of the remaining characters.

// NOTE : sub-sequence length should be greater than or equal to 2.

// Input Format:

// The first and the only argument of input contains a string A.
// Output Format:

// Return an integer, 0 or 1:
//     => 0 : False
//     => 1 : True
// Constraints:

// 1 <= length(A) <= 100
// Examples:

// Input 1:
//     A = "abab"

// Output 1:
//     1

// Explanation 1:
//     "ab" is repeated.

// Input 2:
//     A = "abba"

// Output 2:
//     0

// Explanation 2:
//     There is no repeating subsequence.

// Solution 1:
// The idea is that any repeating subsequence of length
// greater than 2 can only exist if any repeating subsequence
// of length 2 exists in the string. So the problem gets
// decomposes to finding a repeating subsequence of length 2
// which can be easily done in O(n2).

// bool check(pair<int, int> &a1, pair<int, int> &a2)
// {
//     return a1.first < a2.first && a2.second > a1.second;
// }

// int Solution::anytwo(string A)
// {
//     map<string, pair<int, int>> m;
//     for (int i = 0; i < A.length(); i++)
//     {
//         for (int j = i + 1; j < A.length(); j++)
//         {
//             string s;
//             s.push_back(A[i]);
//             s.push_back(A[j]);
//             pair<int, int> p = make_pair(i, j);
//             if (m.count(s))
//             {
//                 if (check(m[s], p))
//                     return true;
//             }
//             else
//                 m[s] = p;
//         }
//     }
//     return false;
// }

// Solution 2:
// The idea to remove all the non-repeating characters from the string
// and return true if the string is not a palindrome. Also if we found 
// the occurrence of a character more than 2 then also we have found a 
// repeating subsequence

bool isPalindrome(string &a)
{
    int l = 0, r = a.length() - 1;
    while (l < r)
        if (a[l++] != a[r--])
            return false;
    return true;
}

bool checkForRepeatedSubsequence(string &a)
{
    unordered_map<char, int> m;
    // counting the character occurrence
    for (char c : a)
    {
        m[c]++;
        if (m[c] > 2)
            return true;
    }
    // removing the repeating characters
    string tmp;
    for (char c : a)
        if (m[c] > 1)
            tmp.push_back(c);
    // checking if is a palindrome or not
    return !isPalindrome(tmp);
}

int Solution::anytwo(string A)
{
    return checkForRepeatedSubsequence(A);
}
